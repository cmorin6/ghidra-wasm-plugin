package wasm.analysis;

import java.io.IOException;
import java.util.Iterator;

import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalysisPriority;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.symbol.RefType;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;
import wasm.WasmLoader;
import wasm.util.WasmInstructionUtil;
import wasm.util.WasmInstructionUtil.OPCODES;

public class WasmFunctionRefrenceAnalyzer extends AbstractAnalyzer {

	// Note:
	// This Analyzer is necessary because calls are generated by callother mechanism
	// and aren't picked-up automatically by the disassembler.

	// TODO : find why generated references have the "offset" prefix in the listing.

	private static String DESCRIPTION = "Create references for function calls.";

	public WasmFunctionRefrenceAnalyzer() {
		super(WasmLoader.WEBASSEMBLY + " function reference", DESCRIPTION, AnalyzerType.INSTRUCTION_ANALYZER);
		setPriority(AnalysisPriority.REFERENCE_ANALYSIS.before().before().before().before());
		setDefaultEnablement(true);
		setSupportsOneTimeAnalysis();
	}

	@Override
	public boolean canAnalyze(Program program) {
		return WasmLoader.WEBASSEMBLY.equals(program.getExecutableFormat());
	}

	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		Iterator<Function> fiter = program.getFunctionManager().getFunctions(set, true);
		while (fiter.hasNext()) {
			monitor.checkCanceled();
			Function function = fiter.next();
			InstructionIterator iiter = program.getListing().getInstructions(function.getBody(), true);
			while (iiter.hasNext()) {
				Instruction instr = iiter.next();
				try {
					if (instr.getByte(0) == OPCODES.CALL && instr.getOperandReferences(0).length==0) {
						long funcIdx = WasmInstructionUtil.getFirstInstrOperand(instr);
						WasmFunctionData funcData = WasmModuleData.get(program).getFunctions().get((int) funcIdx);
						Address dest = funcData.getEntryPoint();
						instr.addOperandReference(0, dest, RefType.UNCONDITIONAL_CALL, SourceType.ANALYSIS);
					}
				} catch (IOException | MemoryAccessException e) {

				}
			}
		}

		return true;
	}

}
